//重建二叉树：
//思路:
//1：先在前序遍历结果的数组中取出第一个节点当成根节点
//2：在遍历中序遍历结果，将各节点找出来，分成两个新的区间，然后递归重建二叉树即可
import java.util.*;
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre.length==0||in.length==0){
            return null;
        }
        //思路：取出前序中的根节点，然后继续遍历，当成左右子树的根节点
        //然后找到中序遍历结果中的根节点，分成左右子树
        TreeNode root=new TreeNode(pre[0]);
        
        //在中序遍历结果中找到跟：
        for(int i=0;i<in.length;i++){
            if(in[i]==pre[0]){
                root.left=reConstructBinaryTree(Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i));
                root.right=reConstructBinaryTree(Arrays.copyOfRange(pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length));
                break;
            }
        }
        return root;
    }
}

//二进制中数字1的个数：
//思路：
//1：暴力法，直接循环遍历计算++即可
//2：简单法：和暴力差不多：就是使用字符串，将其变成一个二进制的字符串
public class Solution {
    public int NumberOf1(int n) {
        String s=Integer.toBinaryString(n);
        int count=0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='1'){
                count++;
            }
        }
        return count;
    }
}

//求一个数的指数：
public class Solution {
    public double Power(double base, int exponent) {
        //在这里要考虑指数的正负
        //1:当底数为0的时候，不管怎么样都是0
        if(base==0.0){
            return 0.0;
        }
        //2：当指数为正的时候，乘以指数的次数即可
        double result=1;
        int e=Math.abs(exponent);
        while(e!=0){
            result=result*base;
            e--;
        }
        //3：当指数为符的情况，坟墓就是为正的情况下的
        if(exponent<0){
            result=1/result;
        }
        return result;
  }
}

//在字符串1中求出出现字符串2的次数

//求字符串中对应字符出现的次数
    public static void main(String[] args){
        String str="dajhudanudhahdiancijaniahnkaio";
        Map<Character,Integer> map=new HashMap<Character,Integer>();
        //将字符串转成字符数组进行遍历
        char[]arr=str.toCharArray();
        for(char ch:arr){
            if(map.containsKey(ch)){
                int count=map.get(ch);
                map.put(ch,count+1);
            }else{
                map.put(ch,1);
            }
        }
    }